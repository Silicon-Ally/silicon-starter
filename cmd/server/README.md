# Server

The directory contains the backend server server's code and configuration.

## Usage

Follow the [Getting Started instructions](/README.md#getting-started) to run the backend.

```bash
# This starts up a local Postgres server.
bazel run //scripts:run_db

# Then, in another terminal, start the backend server
# This script builds and runs the backend server using the flags in `configs/local.conf`
bazel run //scripts:run_backend

# If you want to test the end to end experinece, also start up the frontend to
# see the project running locally on http://localhost:3000
cd frontend; npm run frontend
```

You should see some Bazel output followed by a big 'Silicon Starter'
logo in ASCII art. Once this shows up, the server is running. You'll see
any logs or errors generated by the server in that console.

## Understanding the Backend Server

All the Backend Server does is expose three endpoints over HTTP.

- `POST /api/sessionLogin` - A login handler to allow users to get cookies in
exchange for credentials, and handle the creation of new users in your system.
- `POST /api/sessionLogout` - A logout handler to clear cookies and revoke
session tokens.
- `GET/POST /api/graphql` - A GraphQL API endpoint to allow users to call your GraphQL resolvers behind
authorization. 
   - GraphQL is a way of defining a set of  query and mutation methods that
   will auto generate typings for both your frontend and backend, ensuring
   type + method safety between the two servers. The best way to see this in
   practice is to see how the contents of  `schema.graphqls` correspond to the
   methods in `tasks.go` and `users.go` (their backend implementation), and
   see how the methods are called on the  frontend by searching for eacn method
   name.

That's it! When you want to add additional functionality, it will typically
be through adding a GQL query or mutation method. 

If you do need to add additional HTTP handlers
(for things like async tasks), you can add them in `main.go`.

## Updating GraphQL Schema

The GraphQL schema is managed in
[`graph/schema.graphqls`](/cmd/server/graph/schema.graphqls). Any time you
change it, Bazel will rebuild the generated code automatically. To view the
generated code, run:

```bash
bazel build //cmd/server:gql
```

which will produce some output like:

```plain text
INFO: Analyzed target //cmd/server:gql (0 packages loaded, 0 targets configured).
INFO: Found 1 target...
Target //cmd/server:gql up-to-date:
  bazel-bin/cmd/server/generated/generated.go
  bazel-bin/cmd/server/model/models_gen.go
INFO: Elapsed time: 0.167s, Critical Path: 0.00s
INFO: 1 process: 1 internal.
INFO: Build completed successfully, 1 total action
```

You can view the model code (the backend type bindings) by viewing
`bazel-bin/cmd/server/model/models_gen.go` and you can view the generated
'glue' code by viewing `bazel-bin/cmd/server/generated/generated.go`.

The frontend code isn't (currently) automatically regenerated, it lives in
`frontend/graphql/generated/`, and is updated with `cd frontend && npm run
graphql-gen`
